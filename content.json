{"pages":[],"posts":[{"title":"Android Studio 插件开发","text":"Android Studio插件简介Android Studio插件，如果使用过flutter、gradle插件可能并不陌生，如图中我们平常使用gradle task的插件即为一个AS插件。AS插件可以为我们提供IDE中的使用界面、后台执行逻辑等等功能。 我最近在开发一个多仓管理的插件，翻阅资料发现目前intellij的源码文档很少，这里就把我读到用到的部分intellij的open-api中的代码分享一下，使用这些api将帮助我们快速的完成一些内容的开发，这其中大部分都来自于ide的源码。这里贴上ide源码的链接，想要了解IDE更多内部机制可以通过阅读源码来探究。 https://github.com/JetBrains/intellij-community 本篇主要分析一下常用Intellij的几个实用api，都是从上面IDE的源码中捞出来的，希望能帮到开发相关插件的同学节省时间。开发时间为2019.9，不确定其中的api在最新版IDEA和Android Studio中仍然适用，仅供参考。 整体方向无论是IDEA还是Android Studio，都是基于java编写的，我们在写插件的时候也是使用java语言，并使用./gradlew runIde的命令运行我们的程序。UI的编写可以使用IDEA中的Java GUI，这样可以直接通过组件拖拽来完成简单的开发。但是想要完成更精美的UI还是建议完全用代码实现，由于java中缺少类似于安卓中relative layout和富文本等等组件，因此在开发中使用swing也会更加‘原始’，不熟悉这部分UI编写可以直接新建form文件并使用拖拽组件进行开发。 实现一个按钮插件的配置定义在resources/META-INF/plugin.xml中，如果想定义一个菜单的按钮或右键按钮，请使用以下action来配置，通过更改group-id，我们可以更改此按钮的位置。 12345&lt;action id=\"MRInfoAction\" class=\"com.example.test.ExampleAction\" text=\"按钮文本\" description=\"描述信息\"&gt; &lt;add-to-group group-id=\"EditorPopupMenu\" anchor=\"last\"/&gt; &lt;keyboard-shortcut keymap=\"$default\" first-keystroke=\"meta M\"/&gt; &lt;/action&gt; 这个ExampleAction要继承自AnAction，需要实现actionPerform方法，方法传入一个AnActionEvent，这个方法内需要实现的就是AnAction需要执行的过程了。 如果想让按钮不需要index就可以点按，请实现DumbAware并加入以下代码 1234@Override public boolean isDumbAware() { return true; } 实现一个面板同样在resources/META-INF/plugin.xml中，如果想定义一个侧边栏，请使用以下配置 12&lt;extensions defaultExtensionNs=\"com.intellij\"&gt; &lt;toolWindow id=\"xxx\" icon=\"xxx\" anchor=\"left\" factoryClass=\"com.example.test.ExampleFactory\"/&gt; 这个ExampleFactory要继承自ToolWindowFactory，实现一个createToolWindowContent方法，这个方法用来创建面板，会传入项目project和toolwindow两个参数。 实现按钮打开Android Studio如果想实现一键打开AndroidStudio的功能，我们就要深入Intellij的源码来看一下打开操作是如何实现的 12345678910111213141516171819202122IdeFrame frame = IdeFocusManager.getGlobalInstance().getLastFocusedFrame();final Project projectToClose = frame != null ? frame.getProject() : null;EnumSet&lt;PlatformProjectOpenProcessor.Option&gt; options = EnumSet.noneOf(PlatformProjectOpenProcessor.Option.class);final File tempFile = new File(mModel.getLocalPath());final VirtualFile baseDir = ApplicationManager.getApplication().runWriteAction( (Computable&lt;VirtualFile&gt;) () -&gt; LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempFile));Project project = PlatformProjectOpenProcessor.doOpenProject(baseDir, projectToClose, -1, null, options); if (project != null) { MultiRepoProjectCreator.disableGradleProjectMigrationNotification(project); MultiRepoProjectCreator.disableUserConfig(project); StartupManager.getInstance(project).registerPostStartupActivity( () -&gt; ApplicationManager.getApplication().invokeLater( () -&gt; { // We want to show the Project view, not the Android view since it doesn't make the Dart code visible. DumbService.getInstance(project).runWhenSmart( () -&gt; { ProjectView.getInstance(project).changeView(ProjectViewPane.ID); // If the window still does not pop to top, see DartVmServiceDebugProcess.focusProject(). ProjectUtil.focusProjectWindow(project, true); }); }, ModalityState.defaultModalityState())); 可以看到，这里是通过StartupManager来实现的打开窗口，我们只需要使用doOpenProject()传入Project即可实现打开的这一操作。 实现文件缓存当我们代码更改的时候，intellij不会实时将我们的更改写入文件，而是写入内存，因此如果想在插件中读取所有的更改，我们就需要将所有的更改先写入文件中。其实如果当我们打开terminal或鼠标在编辑器中失去焦点，ide就会自动帮我们执行这一步操作，在我们的插件中我们通过调用以下函数也能实现相似功能。 12345private void refresh() { FileDocumentManager.getInstance().saveAllDocuments(); SaveAndSyncHandler.getInstance().refreshOpenFiles(); VirtualFileManager.getInstance().refreshWithoutFileWatcher(true);} 选取文件当我们需要用户选取某一文件路径的时候，Intellij为我们提供了选取文件的接口 实现这样的文件选择器我们只需要使用FileChooserDescriptor类即可，然后把它加载一个TextFieldWithBrowseButton对象中就可以实现这样的功能，具体实现代码如下所示 12345678910111213FileChooserDescriptor localPathChooserDescriptor = new FileChooserDescriptor(false, true, false, false, false, false) { @Override public boolean isFileSelectable(VirtualFile file) { VirtualFile gitFile = file.findChild(\".git\"); if (gitFile != null &amp;&amp; gitFile.isDirectory()) { return true; } return false; } };localPathChooserDescriptor.setTitle(\"选择路径\");localPathChooserDescriptor.setForcedToUseIdeaFileChooser(true);//使用idea的窗口打开，而不是苹果的finder，这里IDEA有一个窗口显示的判断逻辑myLocalPath.addBrowseFolderListener(new TextBrowseFolderListener(localPathChooserDescriptor)); 这样我们就有如下可以选择路径的UI 实现异步后台运行我们平时在用的很多task，例如update indices和gradle sync，都是通过Background Task来实现的，可以在我们的右下角看到 这一Task队列是由platform-api.jar中的Task类里Backgroundable来实现的。这里当我们需要添加一个后台运行队列的时候，只需要将我们需要干的事放到run()中，然后在progress中运行task，就可以得到 123456789101112131415161718192021222324Task.Backgroundable task = new Task.Backgroundable(project,\"text\",false) { @Override public void run(@NotNull ProgressIndicator indicator) { //这里是background的执行 } @Override public void onSuccess() { super.onSuccess(); //这里是background执行成功的操作 } @Override public void onCancel() { super.onCancel(); //这里是background被用户取消的操作 } @Override public void onThrowable(@NotNull Throwable error) { super.onThrowable(error); //这里是抛出异常的操作 }};ProgressManager.getInstance().runProcessWithProgressAsynchronously(task, new BackgroundableProcessIndicator(task)); 异常处理我们的插件异常，除了自己catch住并且写入log中的，还有很多是会爆在IDE中的，这些异常会显示在右下角的红色感叹号中，点开会有IdeErrorsDialog弹出。如果开发一个插件，我们希望收集所有的插件异常，这时候就需要给IDE的消息弹出加一个监听器，这里我们还需要使用pluginId来定位问题出处，如以下代码所示。 1234567891011121314151617181920212223MessagePool.getInstance().addListener(new MessagePoolListener() { @Override public void newEntryAdded() { List&lt;AbstractMessage&gt; errorList = MessagePool.getInstance().getFatalErrors(true,true); if(errorList.size()!=0){ AbstractMessage abstractMessage = errorList.get(errorList.size()-1); PluginId pluginId = IdeErrorsDialog.findPluginId(abstractMessage.getThrowable()); if(pluginId.getIdString().equals(\"xxx\")){ //具体操作 } } } @Override public void poolCleared() { } @Override public void entryWasRead() { }}); 这里IDE将异常信息封装为AbstractMessage类，通过这个类来实现很多具体方法，如果想对这一message进行操作，例如设为已读，只需要拿到对应AbstractMessage即可。 执行系统命令这里我们可以直接使用java中的process来执行一个shell的cmd命令，方式如下 1Process p = Runtime.getRuntime().exec(new String[]{\"sh\", \"-c\", cmd}); 使用包装好的UIDefaultActionGroupintellij的源码为我们包装了按钮组这一个概念，即使用DefaultActionGroup来实现，具体来讲，我们可以新建一个ActionGroup的实例，然后在JPanel中添加即可。（注意，JPanel不可以选择GridLayoutManager，会出现异常，通常选BoxLayout或BorderLayout）这样我们就实现了类似下图的一排小icon的功能 而往ActionGroup中添加具体的按钮，即直接添加一个AnAction类的继承即可，每添加一个Action就会多一个点击Icon，而AnAction的实现可以如下面代码实现 1234567891011121314151617private class addTokenAction extends AnAction implements DumbAware { private addTokenAction() { super(\"name\", \"description\", Icon icon); } @Override public void actionPerformed(AnActionEvent e) { //加入按钮的点击事件 } @Override public boolean isDumbAware() { return true; //可选，若不实现接口默认false，就会在Updating indice（建立索引）阶段不可以使用 }} NotificationNotification类可以让我们在右下角显示弹窗，实现类似下图的功能，并且将信息打入Event Log中 这里我们可以写一个静态方法放入工具类，只需要实现一个Notification类即可，代码如下所示： 1234567891011121314151617public static void showErrorWithAction(String title, String message, Project project){ final Notification notification = new Notification( \"Messages\", title, message, NotificationType.ERROR); notification.setIcon(MultiRepoIcons.NewProject); notification.addAction(new AnAction(){ @Override public void actionPerformed(@NotNull AnActionEvent e, @NotNull Notification notification) { //加入点击事件 } }); Notifications.Bus.notify(notification); }} 如果希望进行一个弹窗通知，可以使用Messages.showMessageDialog或showErrorDialog方法，注意这个方法不能在子线程中执行，不然会没有效果。 其他UI除此之外，Intellij的官方API还有很多我们能调用的UI，比如loading的转圈UI，可以通过以下代码实现 1private final AsyncProcessIcon myAnimatedIcon = new AsyncProcessIcon(\"add\"); 总之，在编写插件UI的时候，与其自己用java swing去绘制不如看看Intellij源码，很多地方只需要调接口就能轻松完成，例如DialogWrapper类，因此开发之前不如先看看源码再着手编写 总结以上是我开发插件所用到的接口与实用类，除此之外也还用到了JGit和gitlab4j等开源库，后续也会将这两个git和gitlab相关的库与git的命令分享出来。","link":"/2019/11/12/Android-Studio-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"title":"Let&#39;s CURD - Go初识","text":"Let’s CURD! - 初识Go之前有讲过，一直想学习go语言并写一篇go的小博客。今天终于有时间了，把之前的CURD积累个小文档出来。虽然说是客户端工程师，但是怎么能不会点CURD呢？没有CURD的工程师没有灵魂，作为一个有灵魂的工程师还是要会点的。 本篇博文将重点放在如何设计并实现一个简单的go demo，对go工程进行简单的介绍，并对常用的gorm数据库相关，ginex网络框架进行介绍。至于语法，大家还是菜鸟教程快速入门吧，整体来说go的语法还是相对来说简单的（也可能是我写的并不怎么规范），这里只总结几个小特点。下面，CURD开始！ go语法特点go整体来讲，给我的跟kotlin比较相似，都是简洁易懂的代码，实现起来也要比java代码更加节省代码行数，（省略一部分内容后面补充） go工程组成 gorm使用gorm便是实现CURD的核心，我们可以非常方便的利用gorm来完成mysql的CURD操作，如果你对mysql的CURD不熟悉可以搜索mysql数据库相关操作。先举个例子，我们可以新建一个model的结构体如下 123456789type NameModel struct { ID uint `gorm:\"primary_key\" json:\"id\"` NameID string `gorm:\"column:name_id;unique\" json:\"name_id\"` NameStr string `gorm:\"column:name_str;unique\" json:\"name_str\"` NameDescription string `gorm:\"column:name_description\" json:\"name_description\"` CreatedAt time.Time `gorm:\"column:create_time;default:CURRENT_TIMESTAMP\" json:\"created_at\"` UpdatedAt time.Time `gorm:\"column:update_time;default:CURRENT_TIMESTAMP\" json:\"updated_at\"` DeletedAt *time.Time `sql:\"index\" json:\"-\"`} 相信你也能看出里面每个字段的类型。这里我们就可以建立一个简单的表。使用数据库的时候，我们可以使用gorm的dbhandler，示例如下 12345678var recordDB data.NameModelqueryParams := dal.IdeaGroupChat{ NameID: nameId, NameStr: nameStr, NameDescription: nameDescription,}result := data.MySql.Where(&amp;queryParams).FirstOrCreate(&amp;recordDB) 其中MySql定义如下，来连接一个数据库 123456789101112131415var ( MySql *gorm.DB)init(){ var dbConf conf.DBOptional //...省略dbConf的配置 dbHandler := gormdb.NewDBHandlerWithOptional(&amp;dbConf) MySql, err = dbHandler.GetConnection() if err != nil { panic(err) } else { logs.Infof(\"Connect success\") }} 那么这样，这样我们就可以利用gorm来完成数据的增加了，即FirstOrCreate。还有很多方法例如Find，Delete，这样即清晰易懂的完成了mysql的操作。 ginex框架ginex框架是一款很实用的网络框架，可以简单的部署在端口上，而且有优秀的性能。我们可以简单的创建一个路由，然后进行路由，跳转到handler里处理相关的逻辑。使用这一框架可以在命令行执行以下命令 $ go get github.com/gin-gonic/gin 下面我们简单的完成一个小的路由请求demo吧。打开main.go文件，加入以下逻辑 12345678910111213141516const ( ip string = \"192.168.0.108:4000\" //换成你自己的ip)func main(){ router := gin.Default() queryGroup := router.Group(\"/query\") { queryGroup.GET(\"/handle_query\",handlers.middleware ,handlers.HandleQuery) } //需要把ip换成局域网ip地址 router.Run(ip)} 首先创建一个路由，之后建立一个路由组，然后实现对应的GET/POST请求，其中中间件middleware是可选的，可以用作登录验证等操作。那么这样，我们就组出来了一个很简朴的router，可以看出来我们的handlers里面的HandleQuery方法处理了这个url的请求。所以我们可以在根目录的handlers里面放入queryHandler.go文件，内容可以简单如下 123456789101112131415161718192021package handlersimport ( \"github.com/gin-gonic/gin\" \"net/http\")func HandleQuery(ctx *gin.Context){ //响应查询 //查询请求中的字段 value := ctx.DefaultQuery(\"value_id\", \"\") //value := c.DefaultPostForm(\"value\", \"\") 如果使用的是POST请求 if len(value) &gt; 0{ ctx.String(http.StatusOK, \"hello, world\") } } 简单的返回一个hello world吧！这里还查询了GET请求中的value_id字段。如果是使用的POST请求，可以使用注释中的方法。除此之外，我们还可以轻松的完成文件上传等操作，只需file, _ := c.FormFile(“file”)即可。 现在，试试这个url，就可以生效了: 192.168.0.108:4000/query/handle_query还可以试着部署在你设备的ip地址上，这样在同一个局域网内就可以用不同设备来请求啦 实用工具postmanpostman堪称后端调试一大利器，是一款很好用的一款API/接口功能测试工具。可以在postman中实现get/post请求，并查看请求信息/返回头/返回内容。 charles这里charles其实并不是在go调试中很常用的软件，但是无论是安卓调试还是桌面软件的网络测试，charles都是必不可少的工具。charles可以截取Http 和Https 网络封包，也支持重发网络请求，方便后端调试。前段时间头条的http切https的安全合规需求中就使用charles进行http抓包，从而排查问题。 尾声除此之外，其实go能实现的远远不止一个简单的网络请求，后端也不只是mysql的CURD操作。后端常用的还有很多技术，例如用于反向代理和负载均衡的nginx，KV数据库redis，分布式消息队列Kafka等等。由于我并不是专业的后端工程师，感兴趣的同学可以自己深入挖掘哦😈。","link":"/2020/08/22/Let-s-CURD-Go%E5%88%9D%E8%AF%86/"},{"title":"Android相机程序开发","text":"前言这周末写了一个小型的相机app，具体实现功能就是冷启动的Splash-进到主屏幕，出现两个选项，一个是相机获取照片，一个是相册获取照片，点击后进入相机/相册，照相或选取照片，之后弹出照片确认页面。实现这样的一个小demo很简单，下面将简单的介绍这次的开发过程。 代码分析代码规划首先就是对代码进行一个简单的规划，实现这几个内容还是比较简单的，冷启动使用SplashActivity，主界面上放置两个按钮，相机和相册，并且在主界面上使用StartActivityForResult调用相机，这里由于操作比较少就不需要ContentProvider了，只需要声明权限就好。最后还需要一个PhotoEnsure来实现一个确认的效果。 代码实现权限声明下面就是代码的具体实现了，首先我们需要在根目录的AndroidManifest.xml文件中声明如下权限，放在Manifest的最开始就可以 12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt; Splash对于Splash的实现，网上有很多的动画过渡实现参考，后续我将会把我的实现贴出来。 Main接下来就是最主要的——MainActivity了。话不多说，先看代码。 1234567891011121314151617181920212223 final Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); final Intent choosePhotoIntent = new Intent(Intent.ACTION_PICK);/** * 从相机中获取照片 */ camera.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { startActivityForResult(takePictureIntent,REQUEST_FROM_CAMERA); } } ); /** * 从相册中获取照片 */ photo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { startActivityForResult(choosePhotoIntent,REQUEST_FROM_PHOTO_BOOTH); } }); 这里就是对两个核心的按钮的事件监听器声明，点按后触发对应事件。startActivityForResult()对应的就是当前Activity中的onActivityResult()方法，其中的data就是我们想要获取的内容，因此需要复写这个方法，复写如下 12345678910111213141516171819202122232425262728 @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); Intent ensurePhotoIntent = new Intent(MainActivity.this,PhotoEnsureActivity.class); Bitmap photoSelected = null; // 从相册中获得数据 if(requestCode == REQUEST_FROM_PHOTO_BOOTH){ try{ photoSelected = MediaStore.Images.Media.getBitmap(getContentResolver(),data.getData()); }catch (Exception e){ e.printStackTrace(); } } // 从相机中获得数据 if(requestCode == REQUEST_FROM_CAMERA){ photoSelected = data.getExtras().getParcelable(\"data\"); } // 容错 if(data != null){ ensurePhotoIntent.putExtra(\"photo_selected\",photoSelected); startActivity(ensurePhotoIntent); }else{ Toast.makeText(this, \"获取图片失败，请重试\", Toast.LENGTH_SHORT).show(); } }} 这里就体现出来相机和相册的差异性，相机可以直接从data中获得Bitmap类的图片，而相册并不行，需要通过MediaStore来获取，因为返回的是照片的Uri。这样我们合并两种方式的结果到photoSelected中，最后将Bitmap类型的数据放入Bundle，对应键值对（”photo_selected”, photoSelected） ensureensure主要承担了显示一个确认页的功能，通过以下代码提取bundle中的bitmap图片并展示出来 123Bitmap bm = this.getIntent().getParcelableExtra(\"photo_selected\");ImageView img = findViewById(R.id.photo_selected);img.setImageBitmap(bm);","link":"/2019/11/24/Android%E7%9B%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"title":"Windows系统建立博客踩坑","text":"忙活了一个周末，终于完成了个人技术Blog的搭建，windows系统真的是苦不堪言，配置环境坑的一批，作为第一篇文章先简单的把这个周末使用hexo搭建个人博客的坑说一下。 首先要万分感谢程序羊的视频，虽然我网上参考了很多采坑记录，但是主线剧情还是看的 https://www.bilibili.com/video/av44544186/?spm_id_from=333.788.videocard.0 这一视频，如果是mac跟着这个视频做应该会如丝般顺滑。 支持要求使用hexo建立个人博客并部署到GitHub，需要git，node及hexo的支持。各位可以搜索配置git，将SSH private key同步到GitHub，这也将在之后我们远程部署博客使用上。 开始踩坑之后就是正文部分了，这里按照程序羊的视频的顺序来写一下我踩的坑 一： cnpm安装成功无法使用首先就是淘宝的镜像cnpm安装失效，具体现象是cnpm提示安装成功，之后输入cnpm提示 “不是内部或外部命令，也不是可运行的程序或批处理文件”，问题出自windows的环境配置上。 这里在linux上是不需要配置的，而在windows中需要在我的电脑-高级系统设置-环境变量-用户变量中配置npm的路径，在这个路径下也能找到cnpm。我上网查发现每个人的cnpm位置不完全相同，在运行cnpm安装时候会生成一个路径，使用该路径即可，我的路径是 C:\\Users\\xxx\\AppData\\Roaming\\npm 二：hexo init卡死这个问题现象是运行hexo init指令后，卡死在cloning某一个组件，这里目前没有找到很好的解决方法，由于我退出的时候会出现hexo exit相关的提示，说明并不是卡死，而只是速度慢，通过漫长的等待最终我clone成功了，这里小伙伴们如果实在等的漫长看别人好像更换过镜像，可以在别的地方将hexo克隆下来 三：hexo d之后打不开个人博客在hexo d之后直接通过仓库地址打不开博客，这里我是通过GitHub的Environment中 View Deployment找到自己的博客地址的，如果实在无法打开可以尝试这个位置 hexo常用命令后面附带一下hexo的常用命令，供大家编辑博客之后参考。 1 清除hexo缓存1hexo clean 2 生成hexo相对应文件使用hexo generate，指令为 1hexo g 3 将我们的博客部署到远端使用hexo deploy，指令为 1hexo d 4 在本地预览一下博客的内容1hexo s 这样使用生成的地址： http://localhost:4000 就能预览我们的博客了 5 生成新的Post博客1hexo new \"My New Post\"","link":"/2019/11/17/Windows%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91/"},{"title":"gradle插件开发快速上手","text":"gradle插件插件，顾名思义就是插入在宿主过程中。作为一个gradle插件，它最大的作用自然就是在gradle编译打包构建等过程中了。因此，写一个gradle插件让我们添加任务到项目中,帮我们完成测试、编译、打包等工作。 开始！开发一个gradle demo插件，可以在Android Studio中新建一个app，然后新建一个Module作为插件的模块。可以保留原始的app模块，既可以作为使用demo也可以调试的过程中进行测试。gradle插件可以在构建过程中完成代码处理工作，例如新增transform等功能。 配置gradle插件 插件工程中应该含有一个groovy的模块，可以在main目录下新建一个groovy文件夹，然后根据报名路径新建一个目录，里面放入plugin类testPlugin。 同时在resource目录下新建配置，在我的目录下是resources/META-INF/gradle-plugins/whyplugin.properties。里面放入我们的主类的引用implementation-class=com.example.plugin.testPlugin 在whyplugin/build.gradle还应当添加以下配置 12345678910dependencies { implementation localGroovy() implementation gradleApi() implementation 'com.android.tools.build:gradle:4.0.1' implementation 'com.android.tools.build:gradle-api:4.0.1'}repositories { google() jcenter()} 自定义transform使用project.getExtensions().findByType(BaseExtension.class).registerTransform(new TestTransform()），其中的TestTransform 要继承自 Transform。这里的transform就可以理解为一次“变换”，这也是我们插件的核心，即将一部分代码输入然后生成一部分新的代码。在这个transform里我们可以执行相应的例如asm代码插入等等操作，或者对增量代码执行静态代码检测和管控。这里比较常用的就是饿了么的lancet插件，使用这样一个轻量AOP框架可以在编译期实现代码的插桩。 其实之前有讲到组件化，一个很常用的组件化手段就是使用java apt，在组件化中我们使用了apt作为一个router的路由工具，例如@GET(“/xxx/xxxxx”)等，如ARouter，WMRouter等业界方案。这里gradle transform就是除此之外，其实我们还可以进行接口和实现类的注解，进行一个注解的类注入，我们通过一个插件的引入即可完成这个apt的transform。 这里为了验证插件生效，我们可以简单地加入如下一行的代码 1println(\"插件部署成功啦\") 发布这个插件可以在whyplugin/build.gradle文件下加入以下配置 12345678910111213141516publishing { publications { maven(MavenPublication) { groupId 'com.example.plugin' artifactId 'whyplugin' version '1.0.5' from components.java } } repositories { maven { //指定要上传的maven私服仓库 url = \"../xxxxrepo\" } }} 如果想本地发布插件，可以使用publishToMavenLocal命令，之后在app中build.gradle文件中添加 1classpath &quot;com.example.plugin:whyplugin:1.0.5&quot; 就可以在app模块输入命令./gradlew assembleDebug，看到输出，证明插件生效了。 groovy语法groovy整体来看比较类似于java，是java的一种替代语言，可以在良好的运行在jvm上。我们可以新建groovy类等等来进行编译期的操作。关于groovy语法这里不做过多介绍，在构建时也可使用java、kotlin完成。对此有兴趣可以参考Android Gradle权威指南一书。","link":"/2020/08/12/gradle%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"title":"flutter 学习","text":"创建项目 从https://flutter.dev/docs/get-started/install 下载，解压 ~/.bash_profile配置以下环境变量 12345export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn export PATH=${**换成你的****flutter****路径**}/flutter/bin:$PATH 刷新一下变量 1source $HOME/.bash_profile 验证一下，成功 1flutter -v 开搞这里由于我是个安卓开发，直接使用Android Studio进行flutter开发。如果没有使用过可以选择VSCode等工具。 首先注意AS需要安装flutter和dart的plugin，然后restart ide生效 在创建的地方输入以下命令，就可以创建一个flutter的app 1flutter create my_app 刚开始创建的工程结构如下图 简单读一读默认的demo我们来看看默认的代码（实现简单计数器）都做了啥 主函数：• 实现一个runApp函数，这里的参数是个Widget 123void main() { runApp(MyApp());} MyApp类：• 默认build（）函数，返回一个MaterialApp。这个MaterialApp就是我们APP的根。 • 可以看到它是继承StatelessWidget，即只依赖于它们自身的配置信息，因此MyApp本身并不会随着State的change变化。 1234567891011121314151617181920212223242526class MyApp extends StatelessWidget { // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( // This is the theme of your application. // // Try running your application with \"flutter run\". You'll see the // application has a blue toolbar. Then, without quitting the app, try // changing the primarySwatch below to Colors.green and then invoke // \"hot reload\" (press \"r\" in the console where you ran \"flutter run\", // or simply save your changes to \"hot reload\" in a Flutter IDE). // Notice that the counter didn't reset back to zero; the application // is not restarted. primarySwatch: Colors.blue, // This makes the visual density adapt to the platform that you run // the app on. For desktop platforms, the controls will be smaller and // closer together (more dense) than on mobile platforms. visualDensity: VisualDensity.adaptivePlatformDensity, ), home: MyHomePage(title: 'Flutter Demo'), ); }} MyHomePage这个就是实现我们home的widget了。这个就是主页的widget。 • 它继承了StatefulWidget，也就是说变更State后Widget会强制重建。 • createState我理解是create widget内的状态量，里面的这个State描述了widget的状态，就实现了类似安卓中生命周期的状态变化。常用方法如下： ￮ void initState() - 创建State时，位于构造函数之后被调用的方法 ￮ void dispose() - 在 widget 被废弃时被调用 ￮ Widget build() - 在 state 被更新时调用 1234567891011121314151617class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); // This widget is the home page of your application. It is stateful, meaning // that it has a State object (defined below) that contains fields that affect // how it looks. // This class is the configuration for the state. It holds the values (in this // case the title) provided by the parent (in this case the App widget) and // used by the build method of the State. Fields in a Widget subclass are // always marked \"final\". final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();} MyHomePageState这里把build()函数的返回用ide里的图片展示，可以清晰的看到万物皆widget的思想。甚至像Row，Column这种也被抽象为widget，因此在完成一个UI的时候直接可以用组合来完成，各个Widget之间功能没有直接的交叠，也就是没有继承这种思想。 这就意味着，如果要实现一个带图片的button就选择Image和Button组合，如果实现一个带文字的button就选择Text和Button组合，没有安卓中Button和Imageview的这种概念。","link":"/2020/08/01/flutter-%E5%AD%A6%E4%B9%A0/"},{"title":"头条实习-2020上半年总结","text":"关于我我是一个北邮大三学生，目前在字节跳动-产品研发与工程架构部-平台架构部门实习。关于我的部门介绍可以参考去年写的 头条实习总结 引言从今年1月开始，一场疫情突袭全球，我原本的留学计划也全部被打乱。不过受益于远程教学，我今年也得以一直在字节跳动进行实习，而且上半年实习到5月请假也取得了不少产出。下面将对我的产出进行简单介绍。 关于安卓学习https://juejin.im/post/5c8b1bd56fb9a049e12b1692#heading-10 这篇文章提到了安卓需要的各种相关知识点，当然如果是希望通过面试其实需要更多的数据结构、计算机网络、java、算法的知识。我初次接触实习的时候也没有什么安卓开发经验，相信自己，只要基础好学的会很快的。 另外欢迎大家投递头条相关职位，我贴出来个我的个人邮箱：wanghaoyu.michael@bytedance.com 大家可以直接简历发给我，我们直接联系，目前2020校招也已经开启。 该正文了上半年完成的内容总共其实就是两样：云构建+组件化。下面将对头条的云构建工具和安卓客户端组件化进行简单的概述，如果读者感兴趣可以和我深入交流。 云构建工具-研发效率提升在2-3月的1.0版本中，我主要完成的是集群打包，这里涉及了Docker容器相关的部署，。 什么是docker 云构建基本思路 迭代完善 组件化-代码解耦和复用组件化基本思路 头条组件化 迭代完善","link":"/2020/07/01/%E5%A4%B4%E6%9D%A1%E5%AE%9E%E4%B9%A0-2020%E4%B8%8A%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"title":"头条实习总结-2019","text":"引言好久不见，这段时间一直没有更新个人博客是因为期末考试各种烦人的事情，现在也是回到头条继续快乐工作了。其实一直也没有对整个实习过程做一个很好的总结，这篇博文就简单的总结下我去年8月到10月三个月的实习所涉及的工作相关内容，并且形成一个技术交流性质的总结文档。 废话不多说，我们开始吧，我的总结将主要包括以下几个方面——安卓开发，平台架构，研发效率，这也是我在2019年工作中主要做的事情 安卓开发小结这里安卓开发之前也有过一篇文章我谈到安卓开发的一个相机小demo，这里其实这个demo只是简单地调用了相机资源，相册资源，非常适合初学的朋友们模仿。由于我本身在加入头条前并没有安卓相关的实战经验，所以对安卓的虚拟机，aar包和各种库SDK的调用非常不熟悉，还记得第一周周会的时候，我基本上都用来了解dex是什么了。。。。当时探讨如何判断一个方法或者类要不要打入maindex的问题，我连为什么要打maindex（64K方法数限制）都不知道。。。。并且由于所学专业的原因，其实我对Java的编程经验也不是很深，很多并发问题并不知道解法，还不能控制好线程。 因此，到了头条的小白我就只能从0学起，这里还是祭出一张技能树的大图，来源见水印 如果这些都完全理解了，我认为找到个工作是肯定没问题的。还是推荐几本安卓相关的书，如果是对Java开发一无所知的就请把Thinking in Java这本书加入购物车，如果对 当然，距离实战还是有距离的，为什么这么说，就是因为实际的情况远比这些技能树复杂，就像我刚才所说的，实际我们在编写程序的时候很难出现dex方法数受限的情况，因为我们写的demo很少涉及这个问题，我们也不需要在Splash阶段开多个异步线程加载资源，因为我们后端可能根本不会下发多少资源。而且，在自己编码的时候也很少用到CI持续集成，因为我们自己写的demo不会涉及版本发布问题，至于热修复。。。我们写的小demo根本没有迭代周期和崩溃统计，因此当然也就不会涉及 平台架构小结这里主要说一下当一个工程变大之后涉及哪些变化，对了，这里还要mark一篇博文，来教教大家如何快速的上手git，抓取代码从而进行多人合作。常见的方式就是svn和git，我将简单的写一下git的操作指南，争取达到十分中内快速上手。最近上班比较忙，可能要拖到春节后完成了 研发效率小结研发效率就是我在头条这段时间比较着重开发的了，我们通过Android Studio完成了轻量插件以实现RD的研发效率提升。目前很多同类APP客户端由于工程浩大业务繁杂，都会存在多仓开发的情况，并且仓库间存在依赖，难以解耦，因此存在一个需求涉及多个代码仓库的MR提交。我们希望通过多仓插件来进行多个代码仓库的MR提交，能够跑通我们的合码流程（Gitlab-CI），我们还有同学在处理预编译，编写脚本来完成lint代码检查，包大小检查，发布release包等，这样我们的研发流程就能跑通了。 至此，我的2019年实习告一段落，我也回北邮开始准备自己的期末考试，2020年寒假将会继续实习，期待到时候再见！ 相关链接推荐编程，一定是在不断学习的过程中不断提升，这里我mark几个对我很有帮助的文章 ①首先推荐的是厘米姑娘的安卓开发相关文章，正式砍了她的实习经历才让我意识到一个安卓开发工程师是如何一步步成长起来的，也就有了现在我的博客。她的简书链接： https://www.jianshu.com/u/203b606b956c ②第二个推荐的就是程序羊，他的视频介绍了很多程序猿实战的应用，感兴趣的可以进去听一下 https://space.bilibili.com/384068749?from=search&amp;seid=9897226057628769700 ③第三个就是推荐论坛了，掘金里面真的有非常丰富的编程资源，有适合新手的也有适合专家的，大家可以去搜相关的文章看，想要获取比较前沿的技术文档可以参考以下美团技术文章，这里我摘取了前端篇，供大家学习交流，里面也是干货满满 https://s3plus.meituan.net/v1/mss_e63d09aec75b41879dcb3069234793ac/file/%E5%89%8D%E7%AB%AF%E7%AF%87.pdf","link":"/2019/12/18/%E5%A4%B4%E6%9D%A1%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93-2019/"},{"title":"使用Keras搭建NLP自然语言处理模型","text":"本篇博文承担了我在GitHub的开源代码的相关注解，这里给我的Github工程做一个简单的阐释。 代码话不多说，先放代码。我将主要内容放进注释中，逻辑还是比较清晰的，通过keras实现了双向LSTM和CNN。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186# -*- coding：utf-8 -*-import jiebaimport refrom keras_preprocessing import sequenceimport numpy as npimport gensimimport tensorflow.keras as kerasfrom tensorflow.keras import layersimport csv# 配置相关维度，这里统一收敛到这里MAX_DOCUMENT_LEN = 300TRAINING_SIZE = 120000# 使用训练的word2Vec的词向量的配置myPath = 'ml_resources/Word2VecModel.vector'Word2VecModel = gensim.models.KeyedVectors.load_word2vec_format(myPath)EMBEDDING_SIZE = 128# 使用腾讯70000词的词向量的配置# myPath = 'ml_resources/70000_tencent.vector'# Word2VecModel = gensim.models.KeyedVectors.load_word2vec_format(myPath)# EMBEDDING_SIZE = 200# 构造包含所有词语的 list，以及初始化 “词语-序号”字典 和 “词向量”矩阵vocab_list = [word for word, Vocab in Word2VecModel.wv.vocab.items()] # 存储 所有的 词语word_index = {\" \": 0} # 初始化 `[word : token]` ，后期 tokenize 语料库就是用该词典。 “词语-序号”字典word_vector = {} # 初始化`[word : vector]`字典# 初始化存储所有向量的大矩阵，留意其中多一位（首行），词向量全为 0，用于 padding补零。# 行数为所有单词数+1embeddings_matrix = np.zeros((len(vocab_list) + 1, Word2VecModel.vector_size))# 填充上述的字典和大矩阵for i in range(len(vocab_list)): # print(i) word = vocab_list[i] # 每个词语 word_index[word] = i + 1 # 词语：序号 word_vector[word] = Word2VecModel.wv[word] # 词语：词向量 embeddings_matrix[i + 1] = Word2VecModel.wv[word] # 词向量矩阵# print(embeddings_matrix.shape)# print(word_index) # 查看大字典内容# 目前生成六个内容，分别是label标签，总评score，星级别star1，star2，star3def read_csv(filename): content = [] label = [] score = [] star1 = [] star2 = [] star3 = [] with open(filename, encoding='utf-8') as csvDataFile: csvReader = csv.reader((line.replace('\\0', '') for line in csvDataFile), delimiter=',') for row in csvReader: if len(row)&lt;5: print(row) else: content.append(row[0]) label.append(row[1]) score.append(row[2]) star1.append(row[3]) star2.append(row[4]) star3.append(row[5]) print(len(content)) np.random.seed(100) np.random.shuffle(content) np.random.seed(100) np.random.shuffle(label) np.random.seed(100) np.random.shuffle(score) np.random.seed(100) np.random.shuffle(star1) np.random.seed(100) np.random.shuffle(star2) np.random.seed(100) np.random.shuffle(star3) X = np.asarray(content[0:TRAINING_SIZE]) Y = np.asarray(label[0:TRAINING_SIZE], dtype=int) A = np.asarray(score[0:TRAINING_SIZE], dtype=int) B = np.asarray(star1[0:TRAINING_SIZE], dtype=int) C = np.asarray(star2[0:TRAINING_SIZE], dtype=int) D = np.asarray(star3[0:TRAINING_SIZE], dtype=int) return X, Y, A, B, C, DX_train, Y_train, score, star1, star2, star3 = read_csv('ml_resources/training_data_set.csv')print(Y_train.mean()) # 统计数据集中1的占比behavior_input = np.concatenate((score.reshape(-1,1), star1.reshape(-1,1), star2.reshape(-1,1), star3.reshape(-1,1)), axis=1)print(behavior_input)# X_test, Y_test = read_csv('little_test.csv')def tokenizer(texts, word_index): data = [] maxnum = MAX_DOCUMENT_LEN for sentence in texts: new_txt = [] sentence = re.sub(\"[\\s+\\.\\!\\/_,$%^*(+\\\"\\']+|[+——！，。？、~@#￥%……&amp;*（）]+\", \"\", sentence) sentence = jieba.lcut(sentence) # print(sentence) i = 0 for word in sentence: i += 1 # print(word) try: new_txt.append(word_index[word]) except: new_txt.append(0) # print(new_txt) if i &gt; maxnum: # print(new_txt) maxnum = i data.append(new_txt) texts = sequence.pad_sequences(data, maxlen=MAX_DOCUMENT_LEN) print('{} {}'.format('max', maxnum)) return textsX_train = tokenizer(X_train, word_index)# 打乱np.random.seed(100)np.random.shuffle(X_train)np.random.seed(100)np.random.shuffle(Y_train)print(X_train)print(Y_train)print(X_train.shape, ' ', Y_train.shape)# 主训练模型部分input1 = keras.Input(shape=(MAX_DOCUMENT_LEN,))embedding = layers.Embedding(len(word_index), EMBEDDING_SIZE, input_length=MAX_DOCUMENT_LEN, embeddings_initializer=keras.initializers.Constant(embeddings_matrix))(input1)# 使用RNN模型训练部分（结果为x）x = layers.Bidirectional(layers.LSTM(128, return_sequences=True))(embedding)x = layers.Bidirectional(layers.LSTM(64))(x)x = layers.Dense(64, activation='relu')(x)x = layers.Dense(1, activation='sigmoid')(x)# 使用CNN模型训练部分（结果为y）filters = 250kernel_size = 3hidden_dims = 250max_features = 400000## y = layers.Dropout(0.2)(embedding)# y = layers.Conv1D(filters,# kernel_size,# padding='valid',# activation='relu',# strides=1)(y)# # we use max pooling:# y = layers.GlobalMaxPooling1D()(y)## # We add a vanilla hidden layer:# y = layers.Dense(hidden_dims)(y)# y = layers.Dropout(0.2)(y)# y = layers.Activation('relu')(y)## # We project onto a single unit output layer, and squash it with a sigmoid:# y = layers.Dense(1)(y)## # 连接CNN和RNN模型# input2 = keras.Input(shape=(1,))# x = keras.layers.concatenate([x, input2])# x = layers.Dense(2, activation='relu')(x)# output_tensor = layers.Dense(1, activation='sigmoid')(x)model = keras.Model(input1, x)model.compile(optimizer=keras.optimizers.Adam(), loss=keras.losses.binary_crossentropy, metrics=['accuracy'])model.summary()# 模型可视化history = model.fit(X_train, Y_train, batch_size=128, epochs=5, validation_split=0.05, callbacks=[keras.callbacks.TensorBoard(log_dir='result')])model.save(\"TrainResult_full.h5\")","link":"/2019/11/27/%E4%BD%BF%E7%94%A8Keras%E6%90%AD%E5%BB%BANLP%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/"},{"title":"从春节活动看互联网app发展","text":"引言移动互联网时代，各个互联网公司都开始进行自己的活动从而取得流量，例如双十一，双十二等等，而其中刚刚过去的春节活动则是一年中参与人数最多，活动力度最大的活动之一。各个互联网公司也都是卯足了劲，前有支付宝五福分五亿，后有快手十亿红包。从2015年互联网公司首次和春节联欢晚会一起做活动开始，每一年春节活动都能吸引几十亿的流量，春节活动会给我们带来哪些技术难题？存在哪些难以克服的技术壁垒？我们所知的大厂又是使用哪些策略如何克服这些问题？本篇论文我将从以下三点来分析进行春节活动的技术难题及解决方案。 如何保证活动（入口、页面、链接）的动态下发及动态更新？2015年的时候，参加春节活动都需要更新到最新的app版本才可以展现，而今年我们会发现即使没有更新，到了某个时间节点后支付宝或者淘宝会自动显示出某个活动入口tab，这个又是如何做到的？而且在ios、安卓等多个系统中页面高度一致，这又是如何实现的？ 如何应对红包雨等瞬时流量激增带来的后端QPS压力？我们都知道，平时的服务端请求数量是比较稳定的。但是在支付宝和百度客户端的抢红包业务场景中，这个请求将会数十倍激增的，我们也看到，每一次红包雨过后app通常都会锁定提现功能来减轻服务端的压力，那么除此之外，还有什么值得考虑的优化细节？ 如何设计风控策略，从而实现发放红包的安全性，防止刷取红包而造成损失？在抽取高额大奖的时候的权重计算策略又是如何的？在发放短板卡（例如支付宝中的“敬业福”）的策略又是如何？ 通过各种技术手段，以上所提到的技术难题都可以得到解决，因此我们也可以看到，近两年的春节活动明显要比之前丰富的多，不仅是原来的单一玩法，而且要稳定的多，例如支付宝集五福活动，已经不会出现前两天的扫福失败或者提现超时的情况。在我们享受日益增长且多元化的春节活动的时候，其背后的技术也在飞速迭代。这背后的实现是怎样的？本文将从互联网大厂的技术方案和已公开的技术报告进行分析论证。 春节活动简介在分析之前，首先要说一下春节的活动形式，可能读者并没有参与过春节活动。以支付宝为代表的APP春节通常都是在春节前10天左右展开收集卡片的预热活动，到除夕瓜分红包及抽取个别的大奖，再到后面的各种游戏活动。到了最近两年还开始出现了AR，分享好友加速等等新鲜玩法。在深入技术之前，这里我想先简单分析下，春节活动的收益究竟如何？我们每次都觉得春节活动似乎放出了很多钱，投入了几亿甚至近年来的十几亿成本，这个投入真的能取得对等的回报么？ 其实，从近年的百度、快手等app的数据可以看到，整个活动在拉新拉活上都极其有效，而且刺激用户提现绑卡，积累支付的用户群体，例如当年支付宝，十几天的活动就带来了上亿的新用户。我们如果把发出的几亿红包除以用户数，这个成本甚至不到一元，这个拉新成本是极低的。作为对比，现在拉到一个支付宝新用户至少能获得16.88元的红包，而小米、华为等厂商的预装app价格据说也涨到了10元。因此，相比这些拉新拉活方式，春节活动对于单个用户的ROI（投入产出比）是相当可观的，只是因为总量很大。 因此，在春节活动中，如何使用技术保障线上的稳定和app的体验就显得非常重要。下面我将简单的从客户端、服务端和风控三个方面展开分析春节活动中应用到的技术和这些技术背后的思考。 客户端在客户端的分析中，我将对两大难题：保证多个端（IOS、安卓、网页）一致的多端一致性和动态更新（定时更改页面资源）进行技术剖析。 多端一致很早之前，当IOS和安卓两大阵营还没有诞生的时候，所有的东西都呈现在网页上，因此只需要做前端就好。后面当IOS和安卓诞生的时候，众所周知，Android 应用采用 Java 编写，iOS 应用采用 Objective-C 编写，Web 端采用 HTML/CSS/JavaScript 编写，使用的技术栈有很大的差别。像春节活动这样对多端一致有着较高要求的开发，需要的成本也是极高的。很多公司为了节省人力仍然只完成前端，app就像个浏览器一样，在app中将APP中的页面的内容直接使用webView展示前端页面，使用JSBridge进行通信。但是这种体验并不友好，因为前端和app的交互存在很高的时延，因此许多公司就在探索体验更好的的多端一致性技术实现。 这种技术统称为跨端代码实现，近两年也十分火热。各大互联网公司为此都投入大量人力，也出现了各种跨平台技术框架，主要代表有Google的Flutter和FaceBook的React Native，实现了通用的UI和动画，使用一套代码就可以同时运行在安卓和ios上，可以保证安卓和IOS两端有着高度一致的页面和功能，也降低了开发的人力成本，这里我将对这两大技术进行简单的介绍。 React Native，使用JavaScript作为编程语言，是Facebook于2015年4月开源的跨平台移动应用开发框架。其使用JavaScript作为前端开发语言，在跨平台开发中可谓大放异彩。利用通用的web技术不仅能开发出网站，也可以开发手机端web应用和移动端应用程序，在Android、iOS、Web都可以快速应用。Flutter是以Dart语言编写，Flutter开发环境这一套的流程对于前端开发来说并不太友好，因为其使用谷歌自家的Dart语言，其语法特性体验更接近客户端。2017年5月Google I/O大会正式对外公布Flutter，到2018年12月发布Flutter1.0，引发全球大量的开发者和企业开始研究Flutter。Flutter的定位同样是多端一体化，但是以客户端为首，先将Android和iOS基本打通，再逐步向Web端渗透，右图中就是通过flutter实现的ios和安卓端的示例。 使用React Native和Flutter可以快速的打造一个多端相对一致的代码，体验也更接近原生，如今阿里巴巴、字节跳动已经广泛接入Flutter方案。我们也可以预见新的app项目，在没有历史代码迁移包袱的情况下，也会更多的采用类似的方案，实现高效的多端代码开发。 动态更新在近两年的纯洁活动中，很多功能是不需要用户手动触发更新，只需重启应用就可以生效。我们常常会在临近春节发现，支付宝的程序虽然没有更新，但是点进首页就出现了新春活动的banner。要实现这样的动态更新动态下发，主要有以下几个途径：服务端下发配置，插件加载，H5/小程序，热修复/热更新，下面将简单的对这几项技术进行介绍。 最简单的实现便是服务端下发配置，即在软件初始化的时候去服务端拉取配置信息，最早期的淘宝、支付宝中的推荐内容也是用类似的方式实现的。然而，当需要下发通用配置的时候，这种方式就显得有待优化。一方面服务端的请求压力比较高，另外在弱网等条件下会出现请求超时等种种问题，因此H5和热修复/热更新就应运而生了。 以微信为首的H5/小程序，通过官方公布的文档与相关语法结构不难看出，微信小程序的开发技术上是使用一种类似 React Native 的框架来保证程序的原生性和稳定性。React Native已经介绍，可以通过JS的代码来实现类似原生交互，因此这样的程序请求的网页数据可以完全保存在服务端，同时通过JSBridge等相关的类似组件和app进行通信，达到动态更新和交互的效果。然而，这样的体验始终不如原生交互来的直接，网页的交互必然要考虑到延迟等多种因素。 至于热更新，由于苹果全面禁止应用商店上架的应用动态更新其程序中的代码，这里只讨论安卓端。最常见的就是Robust和Tinker技术，实现诸如类替换，资源更新的效果。这里通常的逻辑是通过安卓安装包apk中的dex计算差异，生成一个patch.dex。在客户端加载类的时候会将这个dex中的类覆盖原apk中的类，从而实现热更新/热修复。 客户端小结总的来说，如果不是大公司具有较强技术沉淀的企业，小的团队很可能无法应用类似Robust和Tinker这类比较复杂的技术方案。像唯品会、多点这些app基本是以webview方案为主，使用RN实现多端一致和热修复，这也启发了我们中小团队在技术选型的时候可以先考虑React Native等跨平台技术，从而能更快的部署自己的代码到用户手中。 服务端微信2015年和春晚合作，最高服务端QPS达到1600万，2016年微信服务端最高QPS达到2100万，可以说这个QPS是除了中国头部互联网大厂以外很少有公司可以扛得住的瞬时流量。而且不仅流量大，在活动开始的时候流量峰值也很不确定，没有人能准确预估，因此会给网络带来极强的不确定性压力。当服务端顶不住压力的时候，最明显一个案例的就是微博中出现爆炸性娱乐新闻的时候，由于突发流量激增，应用的请求崩溃超时，很多用户的微博图片加载不出来，下拉无法刷新，如右图所示，这就是服务端的流量无法负载从而产生的后果。因此，服务端的程序稳定性和鲁棒性就显得十分重要。 首先在这里介绍一下服务端是如何顶住压力的。由于机房的搭建涉及到很复杂的技术方案，这里不进行很深入的对于集群、容器部署的介绍。我将简单的进行一些高并发请求方案的分析。常用的方案是缓存、降级和限流，除此之外机房也应该有容灾机制。每一家公司都会采用自己的保密方案，因此，我们就客观分析服务端在开发高并发系统时通用的三把利器：缓存、降级和限流。 缓存：缓存的目的是提升系统访问速度和增大系统处理容量降级：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行限流：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理 对于我们讨论的春节活动，由于缓存和降级策略不能明显带来收益，主要以限流来保障服务端的稳定性。限流方式主要有漏桶算法和令牌桶算法，这里对这两个主流算法进行简单介绍。 漏桶算法• 到达的数据包或请求放置在漏桶中（请求或数据包缓存）漏桶有一定容量，当请求或者数据包到达时漏桶已经满漏，请求和数据包丢弃。 • 漏桶以固定速率漏出请求或数据包，平滑突发流量。 令牌桶算法• 产生令牌：周期性的以一定速率往令牌桶中增加令牌。如果桶中的令牌数达到桶容量，丢弃多余令牌。（一般会定时如100ms添加一次令牌，有些改进算法能实时计算添加令牌数） • 消耗令牌：接受请求或输入数据时会消耗桶中的令牌。以请求或消息为单位时，可以一次消耗一个令牌。在网络传输中，消耗令牌的数量可以根据数据包的大小决定。 • 是否通过：桶中的令牌 &gt;= 所需令牌 时，请求或者数据包通过，否则被限流。对于被限流的请求或者数据包，可以有不同的处理方式：1、直接丢弃；2、进队列等待； 3、可以通过，但需要做特殊标记在2016年的QCon大会，阿里巴巴介绍了阿里线上管控体系，其中主要使用了令牌桶算法来实现限流的目的，可以动态增加/减少令牌，从而对瞬时流量进行比较好的兼容。在双十一、双十二等场景中均有所运用。《亿级流量网站架构》一书中对高并发高流量的网站架构进行了深度分析，对这里感兴趣可以从此书中深入挖掘。 风控测试风控，顾名思义，就是控制风险，防止网络攻击的策略。由于春节红包涉及金钱交易，控制交易的风险就显得尤为重要，否则很可能造成公司的财务损失。因为风控不到位在互联网引起的bad case还是十分常见的，2019年1月20日，电商平台拼多多被曝出现重大BUG，用户可以领取100元无门槛优惠券，据页面显示，该优惠券有效期一年，且全场通用。这次事故中许多羊毛党直接将优惠券充话费，无法追回，给拼多多带来了上亿的损失。淘宝在2020年3月25日也曾爆出内测弹窗的bug，由于热更新模块在之后才加载，因此无法完全的修复，只能等用户覆盖安装，导致淘宝的口碑和用户流失问题。因此，一旦涉及互联网金融，风险控制、预警机制就显得尤为重要。 像老牌的互联网公司阿里，风控早已成为了一项基础设施建设，成为了交易安全的护城河。阿里业务安全智能风控平台，基于大数据实时分析建模技术，通过每个用户行为背后数千个数据指标的实时计算，利用规则引擎、模型引擎、关系网络、团伙分析、设备画像、语义分析、机器视觉等技术对风险进行快速有效的防控。大厂的研发通常会经过研发自测 -&gt; QA回归 -&gt; 版本灰度 -&gt; 正式上线的过程，通过测试将问题提前处理，而且具备周全的熔断机制。而且，阿里应对春节项目也有“时间穿越”来保障，构造出一个未来真实的环境，通过进入这个环境可以做到在真实的未来场景中进行测试和验收，并且通过流程化、卡口化的方式保证无遗漏，辅助自动化驱动，驱动过程数据采集以及问题分析，给出在真实场景下的测试结果。这样就能直接在客户端、服务端均模拟出春节活动的真实场景，从而测试。 在春节活动中，各大公司对于抽卡还有特殊的处理，这里我们简单的讨论下。我们首先考虑，在抽卡活动中，如何能够拿到抽到所有卡从而拿到红包。首先要了解抽卡的规则，在抽卡的过程中常常我们会遇到某一张卡抽不到，例如支付宝中的敬业福，我们可以暂且称之为稀有卡。前面也有提到，这里的稀有卡的发放策略，可以使用令牌桶算法。简单来说，这里的运用就是根据一定请求数量来放入令牌，达到某个阈值X就会发出一个稀有卡，并且去掉N个令牌。这样，就能精准的控制发稀有卡的数量，而且保证稀有卡发放是根据流量浮动的。 另一个问题就是对用户的判断。我们常常发现在淘宝抽卡之后，在支付宝登陆后app内会同步显示出来我们卡的数量，这是如何实现的呢？当然一种机制是验证是直接根据用户的uid来判断。但是当我们如果有一个App不是登陆状态呢？这里最常用的策略是根据一个设备的did（Android）/IDFA（IOS）来判断是否是同一个账号。根据行为数据生成用户画像，一旦存在潜在风险，用户就会进入风控黑名单，从而不会产生集齐卡片的效果。 总结近年来，我们可以看到春节活动、双十一、618等等狂欢活动越来越多，而且参与的用户人数也是屡创新高。可以明显的感觉到春节活动发展之快，近五年从原来的支付宝、微信到现在的百度、抖音、快手等等百家齐放。从之前的单一app的扫码到现在各种各样的花样AR活动，其背后的技术也在迅速的迭代，很多全新技术手段的落地也让我们体验到更流畅更丰富的内容。本文对春节活动背后的技术进行了简单的分析，很多大厂的保密“杀手锏”武器，如ios热更新等等作者也并不是十分了解，读者如果有兴趣可以关注美团技术团队、微信技术团队和国外的React Native、Google的官方渠道了解更多。 参考内容 HTTPS://WWW.IMOOC.COM/ARTICLE/283023 支付宝17年新春红包技术体系剖析 HTTPS://S3PLUS.MEITUAN.NET/V1/MSS_E63D09AEC75B41879DCB3069234793AC/FILE/%E5%89%8D%E7%AB%AF%E7%AF%87.PDF 美团点评2019技术年货-前端篇 HTTPS://JUEJIN.IM/ENTRY/56E7BB6D5BBB50004C259A83 从 0 到 1 构建美团压测工具 HTTPS://WWW.JIANSHU.COM/P/C02899C30BBD 漏斗算法和令牌桶算法的理解 HTTPS://BAIKE.BAIDU.COM/ITEM/令牌桶算法/6597000?FR=ALADDIN 令牌桶算法 HTTPS://JUEJIN.IM/POST/5A260C6AF265DA43294DE65A 微信朋友圈：应对春节千亿访问量背后的故事 HTTPS://BLOG.CSDN.NET/TAOBAOJISHU/ARTICLE/DETAILS/99830639 揭秘阿里测试技术最高奖项目——“时间穿越” HTTPS://PATENTS.GOOGLE.COM/PATENT/CN1536815A/ZH%EF%BC%89 华为专利 采用令牌漏桶进行报文限流的方法 HTTPS://LEARNKU.COM/DOCS/BUILD-WEB-APPLICATION-WITH-GOLANG/027-CONCURRENCY/3165 GO WEB编程 HTTPS://WWW.ZHIHU.COM/QUESTION/382359511 知乎 如何看待阿里S1级事故，淘宝3.25重大BUG问题？ HTTPS://JUEJIN.IM/POST/5BC41D80F265DA0AAA053CA5 蚂蚁金服MPAAS模块化方案","link":"/2020/06/07/%E4%BB%8E%E6%98%A5%E8%8A%82%E6%B4%BB%E5%8A%A8%E7%9C%8B%E4%BA%92%E8%81%94%E7%BD%91app%E5%8F%91%E5%B1%95/"},{"title":"立个FLAG","text":"Flag篇这篇文章纯粹因为本人平时效率较低，因此准备给自己立几个学习flag 前端方面准备学习使用antd或者eleme开源组件库，使用vue架构搭建前端 安卓开发方面我已经看过《第一行代码》，《app研发录》，后续会看安卓开发艺术探索来提升一下自己，这个顺序也是我推荐给刚入门的安卓萌新快速上手的。并且最好自己做一些项目，虽然可能不涉及企业级的合码流程，持续集成，但是对于基本的安卓虚拟机，安卓组件还是能够有所了解的 对于java开发，我之前的基础也比较的弱，现在自己也准备开始补起来了，初步准备先啃四大名著的前两本-Thinking in Java和Effective Java，重新把基本的东西强化一下","link":"/2020/01/16/%E7%AB%8B%E4%B8%AAFLAG/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"插件开发","slug":"插件开发","link":"/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"相机","slug":"相机","link":"/tags/%E7%9B%B8%E6%9C%BA/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"gradle插件","slug":"gradle插件","link":"/tags/gradle%E6%8F%92%E4%BB%B6/"},{"name":"组件化","slug":"组件化","link":"/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"跨平台","slug":"跨平台","link":"/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"name":"字节跳动","slug":"字节跳动","link":"/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"},{"name":"实习经验","slug":"实习经验","link":"/tags/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/"},{"name":"实习总结","slug":"实习总结","link":"/tags/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"keras","slug":"keras","link":"/tags/keras/"},{"name":"tensorflow","slug":"tensorflow","link":"/tags/tensorflow/"},{"name":"nlp","slug":"nlp","link":"/tags/nlp/"},{"name":"自然语言处理","slug":"自然语言处理","link":"/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"},{"name":"春节活动","slug":"春节活动","link":"/tags/%E6%98%A5%E8%8A%82%E6%B4%BB%E5%8A%A8/"},{"name":"客户端","slug":"客户端","link":"/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"后端","slug":"后端","link":"/tags/%E5%90%8E%E7%AB%AF/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Flag","slug":"Flag","link":"/tags/Flag/"}],"categories":[]}